; VDP manual: http://bifi.msxnet.org/msxnet/tech/tms9918a.txt
; More on VDP and speed limits: http://map.grauw.nl/articles/vdp_tut.php

include "msx.h"
;include "svi.h"

  ; Header values for svitool to package it in a tape container
;  dw  start, end-1, start

  org 0xA000

start:
  call INIGRP

  call set_single_pattern_table
  call set_pattern_name_table
  call set_color_palette

  call main_bg_loop
  ;call test_static

  call CHGET ; clear keyboard buffer
  call INITXT
  ret

test_static:
  ld b,0
  ld c,3
  ld d,0
  ld e,0
  call drawfigurexy

  ld b,0
  ld c,3
  ld d,32
  ld e,5
  call drawfigurexy

  ld b,5
  ld c,1
  ld d,0
  ld e,48
  call drawfigurexy

  ld b,7
  ld c,2
  ld d,32
  ld e,32
  call drawfigurexy

  call flushbuffer
  ret

main_bg_loop:
  ld b,0
  ld hl,size_wave
  ld d,7
  ld e,7
  ;ld de,gfxbuffer

.mainloop:
  call clearbuffer
  ;halt
  ;halt
  push bc
  push hl
  ld c,(hl)
  push de
  call drawfigurexy
  ;call drawbuffer
  pop de
  pop hl
  pop bc
  inc b
  inc hl
  bit 7,(hl)
  jr z,.skip
  ld hl,size_wave
.skip:
  call flushbuffer
  ;inc e

  call CHSNS
  jr z,.mainloop
  ret

drawfigurexy:
  ; B = rotation frame (lower 4 bits will be used)
  ; C = size (0-3)
  ; D,E = x,y coordinates in drawing buffer
  call get_figure_ptr
  ; now HL -> figure to draw
  ld a,e
  and 63
  ld e,a
  ld a,d
  and 63
  ex de,hl
  ld h,0 ; HL is now y coordinate in buffer to draw to
  add hl,hl
  add hl,hl
  add hl,hl
  ld bc,gfxbuffer
  add hl,bc
  ex de,hl
  ; HL -> figure to draw
  ; DE -> beginning of first row in buffer to draw to
  ; A = x coordinate

  ld b,32
  ld c,a

.processrow:
  ; B rows left
  ; HL -> current position in figure
  ; DE -> beginning of row in buffer
  ; C = x offset
  push bc
  push hl
  push de
  ; TODO: Should only have to clear one byte (+4) in the line buffer every row
  call clearlinebuffer

  push bc
  ex de,hl
  ld hl,linebuffer
  ld b,0
  srl c
  srl c
  srl c
  add hl,bc
  ex de,hl
  ; DE -> linebuffer+x/8
  ; HL -> current position in figure
  push de
  ldi
  ldi
  ldi
  ldi
  pop hl
  pop bc
  ; C = x coordinate
  ld a,c
  and 7
  jr z,.norotate
  ld b,a
  ; Figure row is now in linebuffer
  ; Now we rotate it to the right place
  ; rotate (hl), (hl+1), ..., (hl+4) B bits
  ; TODO: Use rotation lookup table here so the speed doesn't depend on amount of rotates
.rotate:
  srl (hl)
  inc hl
  rr (hl)
  inc hl
  rr (hl)
  inc hl
  rr (hl)
  inc hl
  rr (hl)
  dec hl
  dec hl
  dec hl
  dec hl
  djnz .rotate
.norotate:
  ; Now copy (OR) linebuffer to drawing buffer
  ; Copy 8 bytes, reset drawing buffer pointer, copy 4 more bytes (wraparound)
  ; TODO: No real need to copy entire linebuffer; only 5 bytes should have to be copied
  pop de
  ld hl,linebuffer
  ld b,8
.lb_copy1:
  ld a,(de)
  or (hl)
  ld (de),a
  inc de
  inc hl
  djnz .lb_copy1
  ; TODO: Faster to do 8 dec de probably
  ld hl,-8
  add hl,de
  ex de,hl
  ld hl,linebuffer+8
  ld b,4
.lb_copy2:
  ld a,(de)
  or (hl)
  ld (de),a
  inc de
  inc hl
  djnz .lb_copy2

  inc de
  inc de
  inc de
  inc de
  ; DE -> next line in drawing buffer
  ld hl,gfxbufferend
  call DCOMPR
  jr nz,.cont
  ld de,gfxbuffer ; wraparound
.cont:
  pop hl
  inc hl
  inc hl
  inc hl
  inc hl
  ; HL -> next line in figure
  pop bc
  ; B = rows left
  djnz .processrow
  ret


clearlinebuffer:
  push bc
  push hl
  ld hl,linebuffer
  xor a
  ld b,12
.ctb_loop:
  ld (hl),a
  inc hl
  djnz .ctb_loop
  pop hl
  pop bc
  ret

linebuffer:
  ds 12

drawbuffer:
  ; B = rotation frame (lower 4 bits will be used)
  ; C = size (0-3)
  ; DE = position in drawing buffer
  call get_figure_ptr

  ld b,32
.db2loop:
  push bc
  ldi
  ldi
  ldi
  ldi
  inc de
  inc de
  inc de
  inc de
  pop bc
  djnz .db2loop

  ret

clearbuffer:
  push bc
  push hl
  ld hl,gfxbuffer
  ; clear 8x8x8 = 512 bytes
  ld b,0
  xor a
.cb_loop:
  ld (hl),a
  inc hl
  ld (hl),a
  inc hl
  djnz .cb_loop
  pop hl
  pop bc
  ret

flushbuffer:
  push bc
  push de
  push hl
  ld hl,0x0000
  call set_vdp_write_addr
  ld hl,gfxbuffer
  ld c,VDP_DW
  ld a,8 ; 8 rows
.fb2_nextrow:
  ld b,64 ; 64 bytes to write per row
.fb2_nexttile:
  ld de,7 ; 1 is added automatically after every outi
  push hl
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  pop hl
  inc hl
  jr nz, .fb2_nexttile ; flag was set from last outi
  ld de,7*8
  add hl,de
  dec a
  jr nz,.fb2_nextrow
  pop hl
  pop de
  pop bc
  ret

get_figure_ptr:
  ; B = rotation frame (lower 4 bits will be used)
  ; C = size (0-3)

  ; gfx start at gfx+(c*16+b)*128
  ld l,c
  ld h,0
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl ; HL = C*16
  ld a,b
  and 15
  ld c,a
  ld b,0
  add hl,bc ; HL = C*16+B
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl ; HL = (C*16+B)*128
  ld bc,gfx
  add hl,bc
  ret

draw_tile:
  ld b,8
  ld c,VDP_DW
.dt_loop:
  outi
  jr nz,.dt_loop
  ret

set_single_pattern_table:
  ; Sets all three parts of the screen to use the same pattern table
  di
  ld a,0
  out (VDP_CW),a
  ld a,128+4
  out (VDP_CW),a

  ld a,128+31
  out (VDP_CW),a
  ld a,128+3
  out (VDP_CW),a
  ei
  ret

set_color_palette:
  ; Sets foreground to white, background to black for the 256 chars used
  ld hl,0x2000
  call set_vdp_write_addr
  ld d,8
  ld b,0
  ld a,0xE1 ; FG=gray BG=black
.scp_loop:
  out (VDP_DW),a
  djnz .scp_loop
  dec d
  jr nz,.scp_loop
  ret

set_pattern_name_table:
  ; Creates an 8x8 matrix of characters 0-63 and repeats it 4x3 over the screen
  ld hl,0x1800
  call set_vdp_write_addr
  ; 01234567012345670123456701234567
  ; 89ABCDEF89ABCDEF89ABCDEF89ABCDEF
  ; etc
  ld d,0 ; row offset
  ld e,24 ; rows left
.spnt_loop2:
  ld c,0 ; col offset
  ld b,32 ; cols left
.spnt_loop1:
  ld a,c
  add a,d
  out (VDP_DW),a
  inc c
  res 3,c
  djnz .spnt_loop1
  ld a,8
  add a,d
  and 63
  ld d,a
  dec e
  jr nz,.spnt_loop2
  ret

; Sets the VDP address registers to HL and prepares for writing
; C will be equal to VDP_DW
set_vdp_write_addr:
  ld c,VDP_CW
  set 6,h
  di
  ld a,l
  out (VDP_CW),a
  ld a,h
  out (VDP_CW),a
  ei
  ret

; TODO: Move this to temporary area
gfxbuffer:
  ; buffer for 8x8 character tiles, each 8 bytes
  ds 8*8*8
gfxbufferend:

gfx:
  incbin "squares.bin"

size_wave:
  db 3,3,3,3,3,3,3,3,3,3,3,2,1,0,1,2,3,3,3,3,-1

end:

  end
