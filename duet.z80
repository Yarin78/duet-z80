; VDP manual: http://bifi.msxnet.org/msxnet/tech/tms9918a.txt
; More on VDP and speed limits: http://map.grauw.nl/articles/vdp_tut.php

include "msx.h"
;include "svi.h"

  ; Header values for svitool to package it in a tape container
;  dw  start, end-1, start

  org 0xA000

start:
  call INIGRP

  call set_single_pattern_table
  call set_pattern_name_table
  call set_color_palette
  call clearbuffer

  call main_bg_loop
  ;call test_static

  call CHGET ; clear keyboard buffer
  call INITXT
  ret

test_static:
  ld b,0
  ld c,3
  ld d,80
  ld e,1
  call drawfigurexy

  ld b,0
  ld c,3
  ld d,32
  ld e,5
  ;call drawfigurexy

  ld b,5
  ld c,1
  ld d,0
  ld e,48
  ;call drawfigurexy

  ld b,7
  ld c,2
  ld d,32
  ld e,32
  ;call drawfigurexy

  call flushbuffer
  ret

main_bg_loop:
  ld b,0
  ld hl,size_wave
  ld d,6
  ld e,0

.mainloop:
  call clearbuffer
  ;halt
  ;halt
  push bc
  push hl
  ld c,(hl)
  push de
  call drawfigurexy
  ;call drawbuffer
  pop de
  pop hl
  pop bc
  inc b
  inc hl
  bit 7,(hl)
  jr z,.skip
  ld hl,size_wave
.skip:
  call flushbuffer
  inc d
  inc e

  call CHSNS
  jr z,.mainloop
  ret

drawfigurexy:
  ; B = rotation frame (lower 4 bits will be used)
  ; C = size (0-3)
  ; D,E = x,y coordinates in drawing buffer

  ; Ensure coordinates are 0 <= x,y < 64
  ld a,d
  and 63
  ld d,a
  ld a,e
  and 63
  ld e,a

  ; setup how to copy bytes from line buffer to drawing buffer
  ; we need to copy Z bytes, then wrap around, then copy 5-Z bytes
  ; where Z is math.max(8-X/8, 5)

  push de
  sra d
  sra d
  sra d
  ld a,8
  sub d
  cp 5
  jr c,.xwrap
  ld a,5
.xwrap:
  ld (.bytes_to_copy1+1),a
  ld d,a
  ld a,5
  sub d
  ld (.bytes_to_copy2+1),a
  pop de

  call get_figure_ptr
  ; now HL -> figure to draw
  ld a,d
  ex de,hl
  ld h,0 ; HL is now y coordinate in buffer to draw to
  add hl,hl
  add hl,hl
  add hl,hl
  ld bc,gfxbuffer
  add hl,bc
  ld c,a
  srl c
  srl c
  srl c
  ld b,0
  add hl,bc

  ex de,hl
  ; HL -> figure to draw
  ; DE -> correct position in the first row in buffer to draw to
  ; A = x coordinate

  ld b,32
  ld c,a

.processrow:
  ; B rows left
  ; HL -> current position in figure
  ; DE -> correct position in row in drawing buffer
  ; C = x offset

  push bc
  push hl
  push de

  ld a,c
  and 7
  ld b,a ; B = number of times to rotate
  ; TODO - if B > 3, rotate left
  ld c,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld e,(hl)
  inc hl
  ld h,(hl)
  ld l,0
  jr z,.norotatefast
.rotatefast:
  srl c
  rr d
  rr e
  rr h
  rr l
  djnz .rotatefast
.norotatefast:
  ld a,l
  ld b,h
  ld hl,linebuffer+4
  ld (hl),a
  dec hl
  ld (hl),b
  dec hl
  ld (hl),e
  dec hl
  ld (hl),d
  dec hl
  ld (hl),c

  ; Now copy (OR) linebuffer to drawing buffer
  ; We always copy 5 bytes, but at some point we need to reset
  ; pointer in drawing buffer to the beginning of the line
  pop de
  push de
  ld hl,linebuffer
.bytes_to_copy1:
  ld b,8 ; this value is modified by code earlier
.lb_copy1:
  ld a,(de)
  or (hl)
  ld (de),a
  inc de
  inc hl
  djnz .lb_copy1
.bytes_to_copy2:
  ld a,4 ; this value is modified by code earlier
  or a
  jr z,.lb_skipcopy2
  ld b,a
  dec de
  dec de
  dec de
  dec de
  dec de
  dec de
  dec de
  dec de
.lb_copy2:
  ld a,(de)
  or (hl)
  ld (de),a
  inc de
  inc hl
  djnz .lb_copy2
.lb_skipcopy2:

  pop de
  ld hl,8
  add hl,de
  ex de,hl
  ; DE -> next line in drawing buffer
  ld hl,gfxbufferend
  call compare_de_hl
  jr c,.cont
  ld hl,-512
  add hl,de
  ex de,hl
.cont:
  pop hl
  inc hl
  inc hl
  inc hl
  inc hl
  ; HL -> next line in figure
  pop bc
  ; B = rows left
  dec b ; TODO change back to djnz if possible
  jp nz,.processrow
  ret

; Z will be set if DE=HL, C set if DE<HL
compare_de_hl:
  ld a,d
  cp h
  ret nz
  ld a,e
  cp l
  ret

linebuffer:
  ds 5

drawbuffer:
  ; B = rotation frame (lower 4 bits will be used)
  ; C = size (0-3)
  ; DE = position in drawing buffer
  call get_figure_ptr

  ld b,32
.db2loop:
  push bc
  ldi
  ldi
  ldi
  ldi
  inc de
  inc de
  inc de
  inc de
  pop bc
  djnz .db2loop

  ret

clearbuffer:
  push bc
  push hl
  ld hl,gfxbuffer
  ; clear 8x8x8 = 512 bytes
  ld b,0
  xor a
.cb_loop:
  ld (hl),a
  inc hl
  ld (hl),a
  inc hl
  djnz .cb_loop
  pop hl
  pop bc
  ret

flushbuffer:
  push bc
  push de
  push hl
  ld hl,0x0000
  call set_vdp_write_addr
  ld hl,gfxbuffer
  ld c,VDP_DW
  ld a,8 ; 8 rows
.fb2_nextrow:
  ld b,64 ; 64 bytes to write per row
.fb2_nexttile:
  ld de,7 ; 1 is added automatically after every outi
  push hl
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  add hl,de
  outi
  pop hl
  inc hl
  jr nz, .fb2_nexttile ; flag was set from last outi
  ld de,7*8
  add hl,de
  dec a
  jr nz,.fb2_nextrow
  pop hl
  pop de
  pop bc
  ret

get_figure_ptr:
  ; B = rotation frame (lower 4 bits will be used)
  ; C = size (0-3)

  ; gfx start at gfx+(c*16+b)*128
  ld l,c
  ld h,0
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl ; HL = C*16
  ld a,b
  and 15
  ld c,a
  ld b,0
  add hl,bc ; HL = C*16+B
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl ; HL = (C*16+B)*128
  ld bc,gfx
  add hl,bc
  ret

draw_tile:
  ld b,8
  ld c,VDP_DW
.dt_loop:
  outi
  jr nz,.dt_loop
  ret

set_single_pattern_table:
  ; Sets all three parts of the screen to use the same pattern table
  di
  ld a,0
  out (VDP_CW),a
  ld a,128+4
  out (VDP_CW),a

  ld a,128+31
  out (VDP_CW),a
  ld a,128+3
  out (VDP_CW),a
  ei
  ret

set_color_palette:
  ; Sets foreground to white, background to black for the 256 chars used
  ld hl,0x2000
  call set_vdp_write_addr
  ld d,8
  ld b,0
  ld a,0xE1 ; FG=gray BG=black
.scp_loop:
  out (VDP_DW),a
  djnz .scp_loop
  dec d
  jr nz,.scp_loop
  ret

set_pattern_name_table:
  ; Creates an 8x8 matrix of characters 0-63 and repeats it 4x3 over the screen
  ld hl,0x1800
  call set_vdp_write_addr
  ; 01234567012345670123456701234567
  ; 89ABCDEF89ABCDEF89ABCDEF89ABCDEF
  ; etc
  ld d,0 ; row offset
  ld e,24 ; rows left
.spnt_loop2:
  ld c,0 ; col offset
  ld b,32 ; cols left
.spnt_loop1:
  ld a,c
  add a,d
  out (VDP_DW),a
  inc c
  res 3,c
  djnz .spnt_loop1
  ld a,8
  add a,d
  and 63
  ld d,a
  dec e
  jr nz,.spnt_loop2
  ret

; Sets the VDP address registers to HL and prepares for writing
; C will be equal to VDP_DW
set_vdp_write_addr:
  ld c,VDP_CW
  set 6,h
  di
  ld a,l
  out (VDP_CW),a
  ld a,h
  out (VDP_CW),a
  ei
  ret

gfx:
  incbin "squares.bin"

size_wave:
  db 3,3,3,3,3,3,3,3,3,3,3,2,1,0,1,2,3,3,3,3,-1

gfxbuffer:    equ start-0x1000 ;8*8*8
gfxbufferend: equ gfxbuffer+8*8*8

end:

  end
